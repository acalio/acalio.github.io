<!DOCTYPE html><html lang="en-us" >

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  
  
  <meta name="generator" content="Wowchemy 4.8.0 for Hugo">
  

  

  
  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Antonio Caliò">

  
  
  
    
  
  <meta name="description" content="GraphX is a new component in Spark for graphs and graph-parallel computation.
At a high level, GraphX extends the Spark RDD by introducing a new Graph abstraction: a directed multigraph with properties attached to each vertex and edge.">

  
  <link rel="alternate" hreflang="en-us" href="/courses/bdanalytics/sparkgraphx/">

  







  




  
  
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  

  
  
  
  <meta name="theme-color" content="#2962ff">
  

  
  

  
  
  
  
    
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css" integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha256-FMvZuGapsJLjouA6k7Eo2lusoAX9i0ShlWFG6qt7SLc=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/github.min.css" crossorigin="anonymous" title="hl-light">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" disabled>
        
      
    

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.css" integrity="sha512-1xoFisiGdy9nvho8EgXuXvnpR5GAMSjFwp40gSRE3NwdUdIMIKuPa7bqoUhLD0O/5tPNhteAsE5XyyMi5reQVA==" crossorigin="anonymous">
    

    

    
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.2.2/lazysizes.min.js" integrity="sha512-TmDwFLhg3UA4ZG0Eb4MIyT1O1Mb+Oww5kFG0uHqXsdbyZz9DcvYQhKpGgNkamAI6h2lGGZq2X8ftOJvF/XjTUg==" crossorigin="anonymous" async></script>
      
    
      

      
      

      
    
      

      
      

      
    
      

      
      
        
      

      
    
      

      
      

      
    
      

      
      

      
    

  

  
  
  
    
      
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,700%7CRoboto:400,400italic,700%7CRoboto+Mono&display=swap">
    
  

  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.css">

  




  


  
  

  

  <link rel="manifest" href="/index.webmanifest">
  <link rel="icon" type="image/png" href="/images/icon_hu28aae1bbe67b568759c86bc74a5bbfe0_150966_32x32_fill_lanczos_center_2.png">
  <link rel="apple-touch-icon" type="image/png" href="/images/icon_hu28aae1bbe67b568759c86bc74a5bbfe0_150966_192x192_fill_lanczos_center_2.png">

  <link rel="canonical" href="/courses/bdanalytics/sparkgraphx/">

  
  
  
  
  
  
  
    
    
  
  
  <meta property="twitter:card" content="summary">
  
  <meta property="og:site_name" content="Antonio Caliò">
  <meta property="og:url" content="/courses/bdanalytics/sparkgraphx/">
  <meta property="og:title" content="Working with Graphs | Antonio Caliò">
  <meta property="og:description" content="GraphX is a new component in Spark for graphs and graph-parallel computation.
At a high level, GraphX extends the Spark RDD by introducing a new Graph abstraction: a directed multigraph with properties attached to each vertex and edge."><meta property="og:image" content="/images/icon_hu28aae1bbe67b568759c86bc74a5bbfe0_150966_512x512_fill_lanczos_center_2.png">
  <meta property="twitter:image" content="/images/icon_hu28aae1bbe67b568759c86bc74a5bbfe0_150966_512x512_fill_lanczos_center_2.png"><meta property="og:locale" content="en-us">
  
    
      <meta property="article:published_time" content="2019-05-05T00:00:00&#43;01:00">
    
    <meta property="article:modified_time" content="2019-05-05T00:00:00&#43;01:00">
  

  



  


  


  





  <title>Working with Graphs | Antonio Caliò</title>

</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class=" ">

  
  
  
    <script>window.wcDarkLightEnabled = true;</script>
  
  
    <script>const isSiteThemeDark = false;</script>
  
  
  <script src="/js/load-theme.js"></script>

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


  












<nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
  <div class="container">

    
    <div class="d-none d-lg-inline-flex">
      <a class="navbar-brand" href="/">Antonio Caliò</a>
    </div>
    

    
    <button type="button" class="navbar-toggler" data-toggle="collapse"
            data-target="#navbar-content" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span><i class="fas fa-bars"></i></span>
    </button>
    

    
    <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
      <a class="navbar-brand" href="/">Antonio Caliò</a>
    </div>
    

    
    
    <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

      
      <ul class="navbar-nav d-md-inline-flex">
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
            
            
            
              
            
            
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#about"><span>Home</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
            
            
            
              
            
            
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#experience"><span>Experience</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
            
            
            
              
            
            
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#featured"><span>Publications</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
            
            
            
              
            
            
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#talks"><span>Talks</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
        

        <li class="nav-item">
          <a class="nav-link  active" href="/courses/"><span>Teaching</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
            
            
            
              
            
            
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#contact"><span>Contact</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/files/cv.pdf"><span>CV</span></a>
        </li>

        
        

      

        
      </ul>
    </div>

    <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">
      
      
      <li class="nav-item">
        <a class="nav-link js-search" href="#" aria-label="Search"><i class="fas fa-search" aria-hidden="true"></i></a>
      </li>
      

      
      
      <li class="nav-item dropdown theme-dropdown">
        <a href="#" class="nav-link" data-toggle="dropdown" aria-haspopup="true">
          <i class="fas fa-moon" aria-hidden="true"></i>
        </a>
        <div class="dropdown-menu">
          <a href="#" class="dropdown-item js-set-theme-light">
            <span>Light</span>
          </a>
          <a href="#" class="dropdown-item js-set-theme-dark">
            <span>Dark</span>
          </a>
          <a href="#" class="dropdown-item js-set-theme-auto">
            <span>Automatic</span>
          </a>
        </div>
      </li>
      

      

    </ul>

  </div>
</nav>



  

<div class="container-fluid docs">
  <div class="row flex-xl-nowrap">
    <div class="col-12 col-md-3 col-xl-2 docs-sidebar">
      





  
    
  




<form class="docs-search d-flex align-items-center">
  <button class="btn docs-toggle d-md-none p-0 mr-3" type="button" data-toggle="collapse" data-target="#docs-nav" aria-controls="docs-nav" aria-expanded="false" aria-label="Toggle section navigation">
    <span><i class="fas fa-bars"></i></span>
  </button>

  
  <input name="q" type="search" class="form-control" placeholder="Search..." autocomplete="off">
  
</form>

<nav class="collapse docs-links" id="docs-nav">
  

  
  
  
    
  

  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/courses/bdanalytics/">Overview</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/courses/bdanalytics/scalaintro/">Introduction to Scala and its Build System</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/courses/bdanalytics/sparkeco/">The Spark Ecosystem</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/courses/bdanalytics/advancedspark/">Spark (More) Advanced Examples</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/courses/bdanalytics/sparksql/">Introduction to Spark SQL</a>

  </div>
  
  <div class="docs-toc-item active">
    <a class="docs-toc-link" href="/courses/bdanalytics/sparkgraphx/">Working with Graphs</a>

  </div>
  
  
</nav>

    </div>

    
    <div class="d-none d-xl-block col-xl-2 docs-toc">
      <ul class="nav toc-top">
        <li><a href="#" id="back_to_top" class="docs-toc-title">Contents</a></li>
      </ul>

      <nav id="TableOfContents">
  <ul>
    <li><a href="#the-property-graph-under-the-hood">The property Graph under the hood</a></li>
    <li><a href="#example-how-to-use-the-property-graph">Example: How to use the Property Graph</a></li>
  </ul>

  <ul>
    <li><a href="#degree-information">Degree Information</a></li>
    <li><a href="#caching-and-uncaching">Caching and Uncaching</a></li>
  </ul>

  <ul>
    <li><a href="#what-is-pregel">What is Pregel</a></li>
    <li><a href="#pregel-in-graphx">Pregel in GraphX</a></li>
  </ul>
</nav>

      
    </div>
    

    <main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 docs-content" role="main">

      <article class="article">

        <div class="docs-article-container">
          <h1>Working with Graphs</h1>

          <div class="article-style">
            <p>GraphX is a new component in Spark
for graphs and graph-parallel computation.</p>
<p>At a high level, GraphX extends the Spark RDD by
introducing a new Graph abstraction: a directed multigraph
with properties attached to each vertex and edge.</p>
<p>To support graph computation, GraphX exposes a set of fundamental operators
(e.g., subgraph, joinVertices, and aggregateMessages) as well
as an optimized variant of the Pregel API.
In addition, GraphX includes a growing collection of graph algorithms
and builders to simplify graph analytics tasks.</p>
<p>In order to use this library in your driver program you need to add the following imports:</p>
<pre><code>import org.apache.spark._
import org.apache.spark.graphx._
import org.apache.spark.rdd.RDD
</code></pre>
<h1 id="the-property-graph">The Property Graph</h1>
<p>It is a directed multigraph with user defined objects attached to each vertex and edge.</p>
<p>A directed multigraph is simply a directed graph that can have multiple edges connecting the same
pair of vertices. This ability enable the possibility to represent multiple relationships between
the nodes in the graph.</p>
<p>Each vertex is associated with a unique 64-bit long key identifier, aka <code>VertexId</code>.
Similarly edges have source and destination identifiers.</p>
<p>The property graph is parameterized over the vertex and edge types, denoted by VD and ED, respectively.
VD and ED are therefore the types associated with objects stored in the graph.</p>
<p>You can also exploit inheritance to have specialized nodes within the graph as follows:</p>
<pre><code>class VertexProperty()
case class UserProperty(val name: String) extends VertexProperty
case class ProductProperty(val name: String, val price: Double) extends VertexProperty
// The graph might then have the type:
var graph: Graph[VertexProperty, String] = null
</code></pre>
<p>In this case the <code>Graph</code> can store two different types of objects.</p>
<p>Graphs inherit all the good things from the RDD.</p>
<ul>
<li>Graphs are immutable, therefore any change to the values contained in a graph instance produce a new instance –
graphs cannot be changed in place!</li>
<li>Graphs are distributed. The Graph is partitioned along the worker nodes using a range of heuristic methods.</li>
<li>Graphs are fault tolerant. Therefore, in case of failure of a worker node, the partition can be easily recreated</li>
</ul>
<h2 id="the-property-graph-under-the-hood">The property Graph under the hood</h2>
<p>A property Graph is simply a compound type having two typed collections (RDDs).</p>
<pre><code>class Graph[VD, ED] {
  val vertices: VertexRDD[VD]
  val edges: EdgesRDD[ED]
}
</code></pre>
<p><code>VertexRDD</code> and <code>EdgesRDD</code> are two specialized and optimized versions of <code>RDD[(VertexId, VD)]</code> and
<code>RDD[Edge[ED]]</code>, respectively. As opposed to a classic RDD, both VertexRDD and EdgesRDD provide specialized
operations tailored for Graph computation.</p>
<h2 id="example-how-to-use-the-property-graph">Example: How to use the Property Graph</h2>
<p>Suppose you want to construct the following graph.








  











<figure id="figure-property-graph">


  <a data-fancybox="" href="/media/img/propGraph.png" data-caption="Property Graph">


  <img src="/media/img/propGraph.png" alt=""  >
</a>


  
  
  <figcaption>
    Property Graph
  </figcaption>


</figure>
</p>
<p>It has the following signature:</p>
<pre><code>val userGraph: Graph[(String, String), String]
</code></pre>
<p>You can construct a Graph object in multiple ways.
The following method is probably the most general and useful.</p>
<pre><code>// Assume the SparkContext has already been constructed
val sc: SparkContext
// Create an RDD for the vertices
val users: RDD[(VertexId, (String, String))] =
  sc.parallelize(Seq((3L, (&quot;rxin&quot;, &quot;student&quot;)), (7L, (&quot;jgonzal&quot;, &quot;postdoc&quot;)),
               (5L, (&quot;franklin&quot;, &quot;prof&quot;)), (2L, (&quot;istoica&quot;, &quot;prof&quot;))))
// Create an RDD for edges
val relationships: RDD[Edge[String]] =
  sc.parallelize(Seq(Edge(3L, 7L, &quot;collab&quot;),    Edge(5L, 3L, &quot;advisor&quot;),
               Edge(2L, 5L, &quot;colleague&quot;), Edge(5L, 7L, &quot;pi&quot;)))
// Define a default user in case there are relationship with missing user
val defaultUser = (&quot;John Doe&quot;, &quot;Missing&quot;)
// Build the initial Graph
val graph = Graph(users, relationships, defaultUser)
</code></pre>
<ul>
<li>
<p><code>Edge</code> is a built in class for storing edges information. It is defined as:</p>
<p>Edge[ED](
srcId: VertexId = 0,
dstId: VertexId = 0,
attr: ED = null.asInstanceOf[ED]) extends Serializable with Product</p>
</li>
<li>
<p>The Graph constructor takes as input two RDDs and a default user, which is needed to handle situations when a vertex
is defined in the EdgeRDD but not in the VertexRDD.</p>
</li>
</ul>
<p>Given a Graph instance, you can query both the RDD containing the vertices and the edges directly from that
instance.</p>
<pre><code>val graph: Graph[(String, String), String] // Constructed from above
// Count all users which are postdocs
graph.vertices.filter { case (id, (name, pos)) =&gt; pos == &quot;postdoc&quot; }.count
// Count all the edges where src &gt; dst
graph.edges.filter(e =&gt; e.srcId &gt; e.dstId).count
// or equivalently
graph.edges.filter{case Edge(src, dst, prop) =&gt; src &gt;  dst}.count
</code></pre>
<p>It should be noted that <code>graph.vertices</code> returns an <code>VertexRDD[(String, String)]</code> in this case, which
it is interpreted as an <code>RDD[(VertexID, (String, String)]</code> – this is why we can use the <code>case</code> construct
(<a href="https://docs.scala-lang.org/tour/pattern-matching.html" target="_blank" rel="noopener">take a look here</a>). The same holds when you access the edges with  <code>graph.edges</code>. This returns an instance
of <code>EdgeRDD</code> which contains objects of type <code>Edge[String]</code>.</p>
<p>In addition to these two mechanism there is a third one, which exposes a triplet view.</p>
<p>A triplet view consists of a series of <code>EdgeTriplet</code> objects. An <code>EdgeTriplet</code> object merges the information
about the two vertices – endpoints of the edges – and the relationship between them.
Conceptually, you can think at the figure:</p>








  











<figure id="figure-edge-triplet">


  <a data-fancybox="" href="/media/img/triplet.png" data-caption="Edge Triplet">


  <img src="/media/img/triplet.png" alt=""  >
</a>


  
  
  <figcaption>
    Edge Triplet
  </figcaption>


</figure>

<p>The <code>EdgeTriplet</code> class extends <code>Edge</code> by adding the attributes of both the source node and the target node.</p>
<p>You can use the triplet view as in the following example:</p>
<pre><code>val graph: Graph[(String, String), String] // Constructed from above
// Use the triplets view to create an RDD of facts.
val facts: RDD[String] =
  graph.triplets.map(triplet =&gt;
    triplet.srcAttr._1 + &quot; is the &quot; + triplet.attr + &quot; of &quot; + triplet.dstAttr._1)
facts.collect.foreach(println(_))
</code></pre>
<h1 id="graph-operations">Graph Operations</h1>
<p>As any other RDD, a graph supports basic operations such as <code>map</code>, <code>filter</code>, <code>reduce</code> and so on.
In addition to that, graphs support a number of transformations specifically meaningful when working with graph.</p>
<p>This kind of operations are defined as <code>GraphOps</code> and most of the time they are accessible as
members of a Graph object.</p>
<p>The following list provide a summary of the major GraphOps directly accessible from a
graph instance.</p>
<pre><code>/** Summary of the functionality in the property graph */
class Graph[VD, ED] {
  // Information about the Graph ===================================================================
  val numEdges: Long
  val numVertices: Long
  val inDegrees: VertexRDD[Int]
  val outDegrees: VertexRDD[Int]
  val degrees: VertexRDD[Int]
  // Views of the graph as collections =============================================================
  val vertices: VertexRDD[VD]
  val edges: EdgeRDD[ED]
  val triplets: RDD[EdgeTriplet[VD, ED]]
  // Functions for caching graphs ==================================================================
  def persist(newLevel: StorageLevel = StorageLevel.MEMORY_ONLY): Graph[VD, ED]
  def cache(): Graph[VD, ED]
  def unpersistVertices(blocking: Boolean = false): Graph[VD, ED]
  // Change the partitioning heuristic  ============================================================
  def partitionBy(partitionStrategy: PartitionStrategy): Graph[VD, ED]
  // Transform vertex and edge attributes ==========================================================
  def mapVertices[VD2](map: (VertexId, VD) =&gt; VD2): Graph[VD2, ED]
  def mapEdges[ED2](map: Edge[ED] =&gt; ED2): Graph[VD, ED2]
  def mapEdges[ED2](map: (PartitionID, Iterator[Edge[ED]]) =&gt; Iterator[ED2]): Graph[VD, ED2]
  def mapTriplets[ED2](map: EdgeTriplet[VD, ED] =&gt; ED2): Graph[VD, ED2]
  def mapTriplets[ED2](map: (PartitionID, Iterator[EdgeTriplet[VD, ED]]) =&gt; Iterator[ED2])
    : Graph[VD, ED2]
  // Modify the graph structure ====================================================================
  def reverse: Graph[VD, ED]
  def subgraph(
      epred: EdgeTriplet[VD,ED] =&gt; Boolean = (x =&gt; true),
      vpred: (VertexId, VD) =&gt; Boolean = ((v, d) =&gt; true))
    : Graph[VD, ED]
  def mask[VD2, ED2](other: Graph[VD2, ED2]): Graph[VD, ED]
  def groupEdges(merge: (ED, ED) =&gt; ED): Graph[VD, ED]
  // Join RDDs with the graph ======================================================================
  def joinVertices[U](table: RDD[(VertexId, U)])(mapFunc: (VertexId, VD, U) =&gt; VD): Graph[VD, ED]
  def outerJoinVertices[U, VD2](other: RDD[(VertexId, U)])
      (mapFunc: (VertexId, VD, Option[U]) =&gt; VD2)
    : Graph[VD2, ED]
  // Aggregate information about adjacent triplets =================================================
  def collectNeighborIds(edgeDirection: EdgeDirection): VertexRDD[Array[VertexId]]
  def collectNeighbors(edgeDirection: EdgeDirection): VertexRDD[Array[(VertexId, VD)]]
  def aggregateMessages[Msg: ClassTag](
      sendMsg: EdgeContext[VD, ED, Msg] =&gt; Unit,
      mergeMsg: (Msg, Msg) =&gt; Msg,
      tripletFields: TripletFields = TripletFields.All)
    : VertexRDD[A]
  // Iterative graph-parallel computation ==========================================================
  def pregel[A](initialMsg: A, maxIterations: Int, activeDirection: EdgeDirection)(
      vprog: (VertexId, VD, A) =&gt; VD,
      sendMsg: EdgeTriplet[VD, ED] =&gt; Iterator[(VertexId, A)],
      mergeMsg: (A, A) =&gt; A)
    : Graph[VD, ED]
  // Basic graph algorithms ========================================================================
  def pageRank(tol: Double, resetProb: Double = 0.15): Graph[Double, Double]
  def connectedComponents(): Graph[VertexId, ED]
  def triangleCount(): Graph[Int, ED]
  def stronglyConnectedComponents(numIter: Int): Graph[VertexId, ED]
}
</code></pre>
<p>Operators can be classified into three different categories:</p>
<ul>
<li>
<p>Property Operators</p>
<p>They are very similar to the map operator of a regular RDD.</p>
<pre><code>class Graph[VD, ED] {
  def mapVertices[VD2](map: (VertexId, VD) =&gt; VD2): Graph[VD2, ED]
  def mapEdges[ED2](map: Edge[ED] =&gt; ED2): Graph[VD, ED2]
  def mapTriplets[ED2](map: EdgeTriplet[VD, ED] =&gt; ED2): Graph[VD, ED2]
}
</code></pre>
<ul>
<li>
<p>Each of these operators yields a
new graph with the vertex
or edge properties modified
by the user defined map function.</p>
</li>
<li>
<p>The structure of the graph is not affected by these operations</p>
</li>
<li>
<p>Note that in order to use GraphX optimization you must prefer the following snippet</p>
<pre><code>val newGraph = graph.mapVertices((id, attr) =&gt; mapUdf(id, attr))
</code></pre>
<p>to the following one</p>
<pre><code> val newVertices = graph.vertices.map { case (id, attr) =&gt; (id, mapUdf(id, attr)) }
val newGraph = Graph(newVertices, graph.edges)
</code></pre>
<p>Although they accomplish the same task, only the first one preserves the structural properties an it
exploits GraphX optimizations.</p>
</li>
<li>
<p>When to use these oprators</p>
<p>Usually, you want to use these transformations to prepare your graph before the application of some
algorithm.
For instance, if you want to prepare the graph in order to compute the page rank.</p>
<pre><code>// Given a graph where the vertex property is the out degree
val inputGraph: Graph[Int, String] =
  graph.outerJoinVertices(graph.outDegrees)((vid, _, degOpt) =&gt; degOpt.getOrElse(0))
// Construct a graph where each edge contains the weight
// and each vertex is the initial PageRank
val outputGraph: Graph[Double, Double] =
  inputGraph.mapTriplets(triplet =&gt; 1.0 / triplet.srcAttr).mapVertices((id, _) =&gt; 1.0)
</code></pre>
</li>
</ul>
</li>
<li>
<p>Structural Operators</p>
<p>Currently GraphX supports only a simple set of commonly used structural operators.</p>
<pre><code>class Graph[VD, ED] {
  def reverse: Graph[VD, ED]
  def subgraph(epred: EdgeTriplet[VD,ED] =&gt; Boolean,
           vpred: (VertexId, VD) =&gt; Boolean): Graph[VD, ED]
  def mask[VD2, ED2](other: Graph[VD2, ED2]): Graph[VD, ED]
  def groupEdges(merge: (ED, ED) =&gt; ED): Graph[VD,ED]
}
</code></pre>
<ul>
<li>
<p><code>reverse</code> returns a new Graph where the direction of every edge is reversed</p>
</li>
<li>
<p><code>subgraph</code> returns the subgraph induced by the conditions provided as input – it is like applying a filter.
This kind of operator is very useful when you need to restrict the graph to a group of vertices of interest,
or when you want to ignore a set of broken links.</p>
<pre><code>// Create an RDD for the vertices
val users: RDD[(VertexId, (String, String))] =
sc.parallelize(Seq((3L, (&quot;rxin&quot;, &quot;student&quot;)), (7L, (&quot;jgonzal&quot;, &quot;postdoc&quot;)),
    (5L, (&quot;franklin&quot;, &quot;prof&quot;)), (2L, (&quot;istoica&quot;, &quot;prof&quot;)),
    (4L, (&quot;peter&quot;, &quot;student&quot;))))
// Create an RDD for edges
val relationships: RDD[Edge[String]] =
sc.parallelize(Seq(Edge(3L, 7L, &quot;collab&quot;),    Edge(5L, 3L, &quot;advisor&quot;),
    Edge(2L, 5L, &quot;colleague&quot;), Edge(5L, 7L, &quot;pi&quot;),
    Edge(4L, 0L, &quot;student&quot;),   Edge(5L, 0L, &quot;colleague&quot;)))
// Define a default user in case there are relationship with missing user
val defaultUser = (&quot;John Doe&quot;, &quot;Missing&quot;)
// Build the initial Graph
val graph = Graph(users, relationships, defaultUser)
// Notice that there is a user 0 (for which we have no information) connected to users
// 4 (peter) and 5 (franklin).
graph.triplets.map(
    triplet =&gt; triplet.srcAttr._1 + &quot; is the &quot; + triplet.attr + &quot; of &quot; + triplet.dstAttr._1
    ).collect.foreach(println(_))

// Remove missing vertices as well as the edges to connected to them
val validGraph = graph.subgraph(vpred = (id, attr) =&gt; attr._2 != &quot;Missing&quot;)
// The valid subgraph will disconnect users 4 and 5 by removing user 0
validGraph.vertices.collect.foreach(println(_))
validGraph.triplets.map(
triplet =&gt; triplet.srcAttr._1 + &quot; is the &quot; + triplet.attr + &quot; of &quot; + triplet.dstAttr._1
).collect.foreach(println(_))
</code></pre>
</li>
</ul>
<p>It should be noted that you are not required to provide two different predicates. The one that you do not provided
is defaulted to a predicate that returns always true</p>
<ul>
<li>
<p><code>mask</code> returns a new graph containing only the vertices contained in the input graph.</p>
<pre><code>  // Run Connected Components
val ccGraph = graph.connectedComponents() // No longer contains missing field
// Remove missing vertices as well as the edges to connected to them
val validGraph = graph.subgraph(vpred = (id, attr) =&gt; attr._2 != &quot;Missing&quot;)
// Restrict the answer to the valid subgraph
val validCCGraph = ccGraph.mask(validGrap
</code></pre>
</li>
<li>
<p><code>groupEdges</code> merges parallel edges in the multigraph.</p>
</li>
</ul>
</li>
<li>
<p>Join Operators</p>
<p>In many cases it is necessary to join data from external collections (RDDs) with graphs.
For example, we might have extra user
properties that we want to merge
with an existing graph or we might want to pull
vertex properties from one graph
into another. These tasks can be
accomplished using the join operators.
Below we list the key join operators:</p>
<pre><code>class Graph[VD, ED] {
  def joinVertices[U](table: RDD[(VertexId, U)])(map: (VertexId, VD, U) =&gt; VD)
    : Graph[VD, ED]
  def outerJoinVertices[U, VD2](table: RDD[(VertexId, U)])(map: (VertexId, VD, Option[U]) =&gt; VD2)
    : Graph[VD2, ED]
}
</code></pre>
<ul>
<li>
<p>The <code>joinVertices</code> returns a new Graph where the vertices are obtaining by merging the original ones with ones
of the input RDD. Then, the user defined map function is applied upon the joined set of vertices.</p>
<pre><code>val nonUniqueCosts: RDD[(VertexId, Double)]
val uniqueCosts: VertexRDD[Double] =
graph.vertices.aggregateUsingIndex(nonUnique, (a,b) =&gt; a + b)
val joinedGraph = graph.joinVertices(uniqueCosts)(
(id, oldCost, extraCost) =&gt; oldCost + extraCost)
</code></pre>
</li>
</ul>
<p>It should be noted that if an RDD contains more that one value for a given vertex index, only the first value
is involved in the join operation.<br>
Also, nodes in the original graph that are not involved in the join process keep their original value.</p>
<ul>
<li>
<p>The <code>outerJoinVertices</code> is similar to the previous operation, the only exception is that the user defined
map function is applied to every node both in the graph and in the input RDD and it can also change the vertex
property type.
For instance, we can set the up a graph for PageRank by initializing the vertex properties with the out degree of each node.</p>
<pre><code>val outDegrees: VertexRDD[Int] = graph.outDegrees
val degreeGraph = graph.outerJoinVertices(outDegrees) { (id, oldAttr, outDegOpt) =&gt;
outDegOpt match { //this ampping function change the type of the property
    case Some(outDeg) =&gt; outDeg
    case None =&gt; 0 // No outDegree means zero outDegree
    }
}
</code></pre>
</li>
</ul>
<p>Note that, since it is not required that every node in the original graph has a counterpart in the input RDD,
the map function returns an Option type.</p>
</li>
</ul>
<h1 id="graph-specific-operations">Graph Specific Operations</h1>
<p>A key step in many graph analytics tasks is aggregating information about the neighborhood of each vertex.</p>
<p>For example, we might want to know the number of
followers each user has or the average age
of the followers of each user.</p>
<p>Many iterative graph algorithms (e.g., PageRank, Shortest Path, and connected components)
repeatedly aggregate properties of neighboring vertices
(e.g., current PageRank Value, shortest path to the source, and smallest reachable vertex id).</p>
<p>The core of this aggregation mechanism in GraphX is represented by the <code>aggregateMessages</code> operation.
This operator applies a user defined <code>sendMsg</code> function to each edge triplet in the graph and then uses the <code>mergeMsg</code>
function to aggregate those messages as their destination vertex.</p>
<pre><code>class Graph[VD, ED] {
  def aggregateMessages[Msg: ClassTag](
      sendMsg: EdgeContext[VD, ED, Msg] =&gt; Unit,
      mergeMsg: (Msg, Msg) =&gt; Msg,
      tripletFields: TripletFields = TripletFields.All)
    : VertexRDD[Msg]
}
</code></pre>
<ul>
<li>
<p><code>sendMsg</code> takes an <code>EdgeContext</code>, which exposes the source and destination attributes along with the edge
attribute and function (<code>sendToSrc</code> and <code>sendToDst</code>) to send messages to the source and destination attributes.</p>
</li>
<li>
<p><code>mergeMsg</code> takes two messages destined to the same vertex and returns a single message.</p>
</li>
<li>
<p><code>tripletFields</code> it is an optional argument that indicates what data is accessed in the EdgeContext (i.e., the source vertex attribute).
The default option is:</p>
<ul>
<li><code>TripletFields.All</code>, which indicates that the user defined <code>sendMsg</code> function may access any fields in the <code>EdgeContext</code></li>
</ul>
<p><code>TripletFields</code> are  a convenient way to specify which part of the <code>EdgeContext</code> is involved in the transformation, allowing
GraphX to apply some optimization.</p>
</li>
</ul>
<p>You can think at a these two function <code>send/mergeMsg</code> as a  <code>map/reduce</code> transformation.
The aggregateMessages returns a VertexRDD[Msg] containing the aggregate messages (of type Msg) destined to
each vertex. All the vertices that did not receive any message are not included in the final result.</p>
<ul>
<li>
<p>Example</p>
<p>In the following example we use the aggregateMessages operator to compute the average age of the more senior followers of each user.</p>
<pre><code>import org.apache.spark.graphx.{Graph, VertexRDD}
import org.apache.spark.graphx.util.GraphGenerators
    
// Create a graph with &quot;age&quot; as the vertex property.
// Here we use a random graph for simplicity.
val graph: Graph[Double, Int] =
  GraphGenerators.logNormalGraph(sc, numVertices = 100).mapVertices( (id, _) =&gt; id.toDouble )
// Compute the number of older followers and their total age
val olderFollowers: VertexRDD[(Int, Double)] = graph.aggregateMessages[(Int, Double)](
  triplet =&gt; { // Map Function
    if (triplet.srcAttr &gt; triplet.dstAttr) {
      // Send message to destination vertex containing counter and age
      triplet.sendToDst((1, triplet.srcAttr))
    }
  },
  // Add counter and age
  (a, b) =&gt; (a._1 + b._1, a._2 + b._2) // Reduce Function
)
// Divide total age by number of older followers to get average age of older followers
val avgAgeOfOlderFollowers: VertexRDD[Double] =
  olderFollowers.mapValues( (id, value) =&gt;
    value match { case (count, totalAge) =&gt; totalAge / count } )
// Display the results
avgAgeOfOlderFollowers.collect.foreach(println(_))
</code></pre>
<p><strong>Note</strong> AggregateMessages works best when the messages are constant sized – so no list, no concatenation.</p>
</li>
</ul>
<h2 id="degree-information">Degree Information</h2>
<p>The following  example shows how to compute the maximum degree of any vertex in the graph.</p>
<pre><code>/ Define a reduce operation to compute the highest degree vertex
def max(a: (VertexId, Int), b: (VertexId, Int)): (VertexId, Int) = {
  if (a._2 &gt; b._2) a else b
}
// Compute the max degrees
val maxInDegree: (VertexId, Int)  = graph.inDegrees.reduce(max)
val maxOutDegree: (VertexId, Int) = graph.outDegrees.reduce(max)
val maxDegrees: (VertexId, Int)   = graph.degrees.reduce(max)
</code></pre>
<h2 id="caching-and-uncaching">Caching and Uncaching</h2>
<p>As any other RDD,if you need to use a graph multiple time you should cache it first – call <code>graph.cache()</code>.</p>
<p>Unlike regular RDDs, graphs are often involved in iterative computations, therefore it would be great to have
a mechanism to <em>uncaching</em> the intermediate graphs created within an algorithm iteration.
Even though these intermediate results are eventually evicted by the system, it still a waste of memory,
thus performance.</p>
<p>There is no trivial way to uncache a Graph, or in general an RDD, for this reason, if you need to design an iterative
algorithm over a graph, it is better to use the <strong>Pregel  API</strong></p>
<h1 id="pregel-api">Pregel API</h1>
<h2 id="what-is-pregel">What is Pregel</h2>
<p>Pregel is a data flow paradigm and system for large-scale graph processing created at Google,
to solve problems that were not easily solvable with an approach based on map-reduce.</p>
<p>If the system remains proprietary at Google, the computational paradigm was adopted by many graph-processing systems,
including GraphX. In order to adopt the Pregel paradigm, most algorithms need to be redesigned
to embrace this approach.
Pregel is essentially a
message-passing interface constrained to the edges of a graph.<br>
To re-design an algorithm in a Pregel fashion, ones should &ldquo;Think like a vertex&rdquo;.
Also, the state of a node is defined by the state of its neighborhood.</p>








  











<figure id="figure-pregel-paradigm">


  <a data-fancybox="" href="/media/img/Screenshot%20from%202020-12-10%2021-47-22.png" data-caption="Pregel Paradigm">


  <img src="/media/img/Screenshot%20from%202020-12-10%2021-47-22.png" alt=""  >
</a>


  
  
  <figcaption>
    Pregel Paradigm
  </figcaption>


</figure>

<p>The above figure shows the Pregel data flow model.
A Pregel computation takes as input:</p>
<ol>
<li>a graph</li>
<li>a set of vertex states</li>
</ol>
<p>At each iteration, referred to as a superstep, each vertex can:</p>
<ol>
<li>send a message to its neighbors,</li>
<li>process the messages received in a previous superstep and update its state, accordingly.</li>
</ol>
<p>Thus, each superstep consists of a round of messages being passed between neighbors and an
update of the global vertex state.</p>
<p>A few examples of Pregel implementations of graph algorithmswill help clarify how the paradigm works.</p>
<ul>
<li>
<p>Example</p>
<p>Imagine you need to compute the maximum value among all the nodes in the network.
The following sequence of figures show how we can accomplish this task with the Pregel paradigm.
The following figure represents the input graph.








  











<figure id="figure-initial-graph">


  <a data-fancybox="" href="/media/img/Screenshot%20from%202020-12-10%2021-57-04.png" data-caption="Initial Graph">


  <img src="/media/img/Screenshot%20from%202020-12-10%2021-57-04.png" alt=""  >
</a>


  
  
  <figcaption>
    Initial Graph
  </figcaption>


</figure>
</p>
<p>In each step a vertex reads the messages received bu its incoming neighbors and
set its state to the maximum value between its own vale and  all the received messages.








  











<figure id="figure-step-1">


  <a data-fancybox="" href="/media/img/Screenshot%20from%202020-12-10%2021-57-16.png" data-caption="Step 1">


  <img src="/media/img/Screenshot%20from%202020-12-10%2021-57-16.png" alt=""  >
</a>


  
  
  <figcaption>
    Step 1
  </figcaption>


</figure>
</p>
<p>If during an iteration a node does not update its state, then it becomes halted.
This means that it will not send any message in the following iteration.








  











<figure id="figure-step-2">


  <a data-fancybox="" href="/media/img/Screenshot%20from%202020-12-10%2021-57-28.png" data-caption="Step 2">


  <img src="/media/img/Screenshot%20from%202020-12-10%2021-57-28.png" alt=""  >
</a>


  
  
  <figcaption>
    Step 2
  </figcaption>


</figure>
</p>
<p>The algorithm proceeds until every node becomes halted.








  











<figure id="figure-step-3">


  <a data-fancybox="" href="/media/img/Screenshot%20from%202020-12-10%2021-57-37.png" data-caption="Step 3">


  <img src="/media/img/Screenshot%20from%202020-12-10%2021-57-37.png" alt=""  >
</a>


  
  
  <figcaption>
    Step 3
  </figcaption>


</figure>
</p>
<p>In general, sever optimization can be applied to the above example.
For instance one may use <em>combiners</em>.</p>
<p>A <em>combiner</em> is a user provided function that can combine multiple messages
intended for the same vertex. This mechanism leads to a reduction in the number
of messages transmitted between the vertices.
In the above example a <em>combiner</em> could collapse multiple messages into a single
one containing the maximum.</p>
<p>Another useful mechanism is offered by the <em>aggregators</em>.
An <em>aggregator</em> enables global information exchange. Each vertex can provide
a value to an aggregator during a superste S, the Pregel framework combines
those values using a reduction operator, and the resulting value is made available to all
the vertices in the subsequent superstep S+1.
Another common way to use aggregators is to elect a node to play a distinguished role in
an algorithm.</p>
<p>There is also a mechanism that allows the removal or the addition of a new vertex
or edge. This is very useful for those algorithms that need to change the graph&rsquo;s
topology – for instance a clustering algorithm might collapse every node belonging
to the same cluster into a single node.</p>
</li>
</ul>
<h2 id="pregel-in-graphx">Pregel in GraphX</h2>
<p>The Pregel implementation of GraphX has some key difference from the original
definition.</p>
<ul>
<li>Messages are compute in parallel as a function of the edgetriplet</li>
<li>The message computation is not only available to recipient of the message, but it is also
available to the sender node</li>
<li>Nodes can only send messages to their direct neighbors – no hops are allowed as in many other
pregel implementations.</li>
</ul>
<p>As in the original Pregel definition, a node that becomes inactive – because it has not
any message to send or to process – is ignored during the superstep.
Also as in the original Pregel, the algorithm terminates when there are no remaining messages.</p>
<p>The signature of the <code>pregel</code> function – which is a member function of <code>Graph</code> –
is defined as follows:</p>
<pre><code>def pregel[A]
      (initialMsg: A,
       maxIter: Int = Int.MaxValue,
       activeDir: EdgeDirection = EdgeDirection.Out)
      (vprog: (VertexId, VD, A) =&gt; VD,
       sendMsg: EdgeTriplet[VD, ED] =&gt; Iterator[(VertexId, A)],
       mergeMsg: (A, A) =&gt; A)
    : Graph[VD, ED] 
</code></pre>
<p>It takes two arguments lists:</p>
<ul>
<li>The first list contains configuration parameters including:
<ul>
<li>The initial message</li>
<li>The maximum number of iterations</li>
<li>The edge direction in which to send messages (by default messages are sent via outgoing links)</li>
</ul>
</li>
<li>The second argument list contains:
<ul>
<li>The user defined function for receiving messages - <code>vprog</code></li>
<li>The user defined function for computing messages - <code>sendMsg</code></li>
<li>The user defined function for combining messages - <code>mergeMsg</code></li>
</ul>
</li>
</ul>
<p>The previous example in GraphX can be solved as follows.</p>
<pre><code>import org.apache.spark.graphx.{Graph, VertexId}
import org.apache.spark.graphx.util.GraphGenerators
val r = scala.util.Random
// A graph with edge attributes containing distances
val graph: Graph[Long, Double] =
  GraphGenerators.logNormalGraph(sc, numVertices = 100).mapEdges(e =&gt; e.attr.toDouble)
val sourceId: VertexId = 42 // The ultimate source
// Initialize the graph such that all vertices except the root have distance infinity.
val initialGraph = graph.mapVertices((id, _) =&gt; r.nextInt)

//pregel
val sssp = initialGraph.pregel(
    Int.MinValue //inital messages 
)(
  (id, currentValue, receivedValue) =&gt; math.max(currentValue, receivedValue), // Vertex Program
  triplet =&gt; {  // Send Message 
    val sourceVertex = triplet.srcAttr //get the property associated with the src vertex
    if (sourceVertex._1 == sourceVertex._2_) //new value match the current one - the node is halted
      Iterator.empty // no messages
    else
      Iterator((triplet.dstId, sourceVertex._1)) //send out the message
    }
  },
  (a, b) =&gt; math.max(a, b) // Merge Message if multiple messages are received from the same vertex
)
println(sssp.vertices.collect.mkString(&quot;\n&quot;))
</code></pre>
<p><strong>Note</strong>
An edge triplet has five properties:</p>
<ul>
<li><code>srcId</code>. The source vertex id</li>
<li><code>srcAttr</code>. The source vertex property</li>
<li><code>stdId</code>. The destination vertex id</li>
<li><code>dstAttr</code>. The destination vertex property</li>
<li><code>attr</code>. The edge property.</li>
</ul>
<hr>
<p>The material for this lesson is available  <a href="https://github.com/acalio/BDAnalytics/blob/main/05-Spark-GraphX/" target="_blank" rel="noopener">here</a></p>

          </div>

          



          
        </div>

        <div class="body-footer">
          <p>Last updated on May 5, 2019</p>

          






  
  

<p class="edit-page">
  <a href="https://github.com/gcushen/hugo-academic/edit/master/content/courses/bdanalytics/sparkGraphX.md">
    <i class="fas fa-pen pr-2"></i>Edit this page
  </a>
</p>




          


          


  
  



        </div>

      </article>

      <footer class="site-footer">
  

  <p class="powered-by">
    
  </p>

  
  






  <p class="powered-by">
    
    Published with
    <a href="https://wowchemy.com" target="_blank" rel="noopener">Wowchemy</a>  —
    the free, <a href="https://github.com/wowchemy/wowchemy-hugo-modules" target="_blank" rel="noopener">
    open source</a> website builder that empowers creators.
    

    
  </p>
</footer>


    </main>
  </div>
</div>


      

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.1.0/instantpage.min.js" integrity="sha512-1+qUtKoh9XZW7j+6LhRMAyOrgSQKenQ4mluTR+cvxXjP1Z54RxZuzstR/H9kgPXQsVB8IW7DMDFUJpzLjvhGSQ==" crossorigin="anonymous"></script>

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js" integrity="sha512-TDKKr+IvoqZnPzc3l35hdjpHD0m+b2EC2SrLEgKDRWpxf2rFCxemkgvJ5kfU48ip+Y+m2XVKyOCD85ybtlZDmw==" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/r.min.js"></script>
        
      

    

    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.js" integrity="sha512-SeiQaaDh73yrb56sTW/RgVdi/mMqNeM2oBwubFHagc5BkixSpP1fvqF47mKzPGWYSSy4RwbBunrJBQ4Co8fRWA==" crossorigin="anonymous"></script>
    

    
    
    <script>const code_highlighting = true;</script>
    

    
    
    
    
    
    
    <script>
      const search_config = {"indexURI":"/index.json","minLength":1,"threshold":0.3};
      const i18n = {"no_results":"No results found","placeholder":"Search...","results":"results found"};
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks",
        'slides' : "Slides"
        };
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.2/anchor.min.js" integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin="anonymous"></script>
    <script>
      anchors.add();
    </script>
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    

    
    

    
    

    
    
    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/wowchemy.min.832c0c66be3ec862b3635a8119cc9647.js"></script>

    






  
  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
